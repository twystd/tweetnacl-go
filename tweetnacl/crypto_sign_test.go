package tweetnacl

import (
	"bufio"
	"bytes"
	"embed"
	"encoding/hex"
	"strings"
	"testing"
)

//go:embed sign_test.input
var fs embed.FS

// --- CryptoSignKeyPair ---

// Adapted from tests/core1.c)
func TestCryptoSignKeyPair(t *testing.T) {
	keypair, err := CryptoSignKeyPair()

	if err != nil {
		t.Errorf("crypto_sign_keypair: %v", err)
		return
	}

	if keypair.PublicKey == nil || len(keypair.PublicKey) != SIGN_PUBLICKEYBYTES {
		t.Errorf("crypto_sign_keypair: invalid public key")
		return
	}

	if keypair.SecretKey == nil || len(keypair.SecretKey) != SIGN_SECRETKEYBYTES {
		t.Errorf("crypto_sign_keypair: invalid secret key")
		return
	}
}

func BenchmarkCryptoSignKeyPair(b *testing.B) {
	for i := 0; i < b.N; i++ {
		CryptoSignKeyPair()
	}
}

// --- CryptoSign ---

// Adapted from http://ed25519.cr.yp.to/python/sign.py.
func TestCryptoSign(t *testing.T) {
	message := []byte{
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79, 0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d, 0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea, 0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59, 0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	expected := []byte{
		0xbe, 0x71, 0xef, 0x48, 0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9, 0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd, 0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92, 0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d, 0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b, 0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b, 0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66, 0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	signed, err := CryptoSign(message, key)

	verify(t, "invalid signed message", expected, signed, err)
}

func TestCryptoSignWithZeroLengthMessage(t *testing.T) {
	message := []byte{}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79, 0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d, 0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea, 0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59, 0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	expected := []byte{
		0xb1, 0x28, 0x9e, 0xdf, 0x55, 0xd7, 0x1f, 0x98,
		0xce, 0xda, 0x85, 0x9b, 0xc9, 0x2e, 0x5d, 0xb3,
		0x9e, 0xca, 0xbe, 0x37, 0x7f, 0x36, 0xb5, 0x7f,
		0x23, 0xde, 0x5f, 0x7c, 0x8b, 0x76, 0x57, 0x2b,
		0x62, 0xa1, 0xd7, 0xd1, 0xee, 0x6d, 0xef, 0xf6,
		0x3b, 0xc4, 0x30, 0xfb, 0x0c, 0xe1, 0xb3, 0x95,
		0xe2, 0x58, 0x4d, 0x0d, 0xd6, 0x51, 0x16, 0x3a,
		0xd0, 0x50, 0xcb, 0x5b, 0x86, 0x07, 0x25, 0x02}

	signed, err := CryptoSign(message, key)

	verify(t, "invalid signed message", expected, signed, err)
}

func TestCryptoSignWithInvalidKey(t *testing.T) {
	message := []byte{
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79, 0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d, 0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea, 0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59, 0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3}

	signed, err := CryptoSign(message, key)

	verifyErr(t, "invalid key", signed, err)
}

func BenchmarkCryptoSign(b *testing.B) {
	message := []byte{
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79, 0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d, 0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea, 0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59, 0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	for i := 0; i < b.N; i++ {
		CryptoSign(message, key)
	}
}

// --- CryptoSignOpen ---

// Adapted from http://ed25519.cr.yp.to/python/sign.py.
func TestCryptoSignOpen(t *testing.T) {
	signed := []byte{
		0xbe, 0x71, 0xef, 0x48, 0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9, 0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd, 0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92, 0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d, 0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b, 0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b, 0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66, 0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	key := []byte{
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	expected := []byte{
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	message, err := CryptoSignOpen(signed, key)

	verify(t, "invalid unsigned message", expected, message, err)
}

func TestCryptoSignOpenWithZeroLengthMessage(t *testing.T) {
	signed := []byte{
		0xb1, 0x28, 0x9e, 0xdf, 0x55, 0xd7, 0x1f, 0x98,
		0xce, 0xda, 0x85, 0x9b, 0xc9, 0x2e, 0x5d, 0xb3,
		0x9e, 0xca, 0xbe, 0x37, 0x7f, 0x36, 0xb5, 0x7f,
		0x23, 0xde, 0x5f, 0x7c, 0x8b, 0x76, 0x57, 0x2b,
		0x62, 0xa1, 0xd7, 0xd1, 0xee, 0x6d, 0xef, 0xf6,
		0x3b, 0xc4, 0x30, 0xfb, 0x0c, 0xe1, 0xb3, 0x95,
		0xe2, 0x58, 0x4d, 0x0d, 0xd6, 0x51, 0x16, 0x3a,
		0xd0, 0x50, 0xcb, 0x5b, 0x86, 0x07, 0x25, 0x02}

	key := []byte{
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	expected := []byte{}

	message, err := CryptoSignOpen(signed, key)

	verify(t, "invalid unsigned message", expected, message, err)
}

func TestCryptoSignOpenWithZeroLengthSignedMessage(t *testing.T) {
	signed := []byte{}

	key := []byte{
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	message, err := CryptoSignOpen(signed, key)

	verifyErr(t, "invalid unsigned message", message, err)
}

func TestCryptoSignOpenWithInvalidKey(t *testing.T) {
	signed := []byte{
		0xbe, 0x71, 0xef, 0x48, 0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9, 0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd, 0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92, 0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d, 0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b, 0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b, 0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66, 0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	key := []byte{
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3}

	message, err := CryptoSignOpen(signed, key)

	verifyErr(t, "invalid unsigned message", message, err)
}

func BenchmarkCryptoSignOpen(b *testing.B) {
	signed := []byte{
		0xbe, 0x71, 0xef, 0x48, 0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9, 0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd, 0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92, 0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d, 0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b, 0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b, 0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66, 0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75, 0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0, 0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a, 0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8, 0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79, 0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d, 0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea, 0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59, 0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54, 0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8, 0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9, 0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab, 0xc8, 0x44, 0xf3, 0x1a}

	for i := 0; i < b.N; i++ {
		CryptoSignOpen(signed, key)
	}
}

// Adapted from http://ed25519.cr.yp.to/python/sign.py.
func TestED25519(t *testing.T) {
	file, _ := fs.Open("sign_test.input")
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		tokens := strings.Split(line, ":")

		if len(tokens) < 4 {
			t.Errorf("Invalid line in file sign.input [%s]", line)
			return
		}

		sk, _ := hex.DecodeString(tokens[0])
		pk, _ := hex.DecodeString(tokens[1])
		m, _ := hex.DecodeString(tokens[2])
		sm, _ := hex.DecodeString(tokens[3])

		signed, err := CryptoSign(m, sk)

		if err != nil {
			t.Errorf("Error signing message [%v]", err)
			return
		}

		if !bytes.Equal(signed, sm) {
			t.Errorf("Invalid signed message - expected [%x]", sm)
			t.Errorf("                       - received [%x]", signed)
			return
		}

		message, err := CryptoSignOpen(sm, pk)

		if err != nil {
			t.Errorf("Error opening signed message [%v]", err)
			return
		}

		if !bytes.Equal(message, m) {
			t.Errorf("Invalid opened message - expected %x", m)
			t.Errorf("                       - received %x", message)
			return
		}

		forgedm := forge(m)
		forgedsm := forgesm(sm)

		signed, err = CryptoSign(forgedm, sk)

		if err != nil {
			t.Errorf("Error signing forged message [%v]", err)
			return
		}

		if bytes.Equal(signed, sm) {
			t.Errorf("Valid forgery [%x][%x]", m, forgedm)
			return
		}

		message, err = CryptoSignOpen(forgedsm, pk)

		if err == nil {
			if bytes.Equal(message, m) {
				t.Errorf("Valid signed forgery [%x][%x]", sm, forgedsm)
				return
			}
		}
	}

	if err := scanner.Err(); err != nil {
		t.Errorf("Error reading file sign.input [%v]", err)
		return
	}
}

func forge(m []byte) []byte {
	if len(m) == 0 {
		return []byte("x")
	}

	fm := make([]byte, len(m))
	ix := len(fm) - 1

	copy(fm, m)

	fm[ix] = byte((fm[ix] & 0x00ff) + 1)

	return fm
}

func forgesm(sm []byte) []byte {
	N := 1
	if len(sm) != SIGN_BYTES {
		N = len(sm) - SIGN_BYTES
	}

	fm := make([]byte, N)
	ix := len(fm) - 1

	if len(sm) == SIGN_BYTES {
		copy(fm, []byte("x"))
	} else {
		copy(fm, sm)

		fm[ix] = byte((fm[ix] & 0x00ff) + 1)
	}

	fsm := make([]byte, SIGN_BYTES+len(fm))

	copy(fsm[0:SIGN_BYTES], sm)
	copy(fsm[SIGN_BYTES:], fm)

	return fsm
}
