package tweetnacl

/*
#include "tweetnacl.h"
*/
import "C"

import (
	"fmt"
)

// The number of bytes in the secret key for crypto_stream.
const STREAM_KEYBYTES int = 32

// The number of bytes in the nonce for crypto_stream.
const STREAM_NONCEBYTES int = 24

// The number of bytes in the secret key for crypto_stream_salsa20.
const STREAM_SALSA20_KEYBYTES int = 32

// The number of bytes in the nonce for crypto_stream_salsa20.
const STREAM_SALSA20_NONCEBYTES int = 8

// Wrapper function for crypto_stream.
//
// Generates a cipher stream of size 'length' as a function of the key and nonce.
//
// Ref. http://nacl.cr.yp.to/stream.html
func CryptoStream(length int, nonce, key []byte) ([]byte, error) {
	stream := make([]byte, length)
	N := (C.ulonglong)(length)

	rc := C.crypto_stream(makePtr(stream),
		N,
		makePtr(nonce),
		makePtr(key))

	if rc == 0 {
		return stream, nil
	}

	return nil, fmt.Errorf("Error generating cipher stream (error code %v)", rc)
}

// Wrapper function for crypto_stream_xor.
//
// Encrypts a message using a secret key and a nonce. The returned ciphertext is the
// plaintext XOR with the output of the stream generated by crypto_stream with the
// secret key and nonce.
//
// Ref. http://nacl.cr.yp.to/stream.html
func CryptoStreamXor(message, nonce, key []byte) ([]byte, error) {
	ciphertext := make([]byte, len(message))
	N := (C.ulonglong)(len(ciphertext))

	rc := C.crypto_stream_xor(makePtr(ciphertext),
		makePtr(message),
		N,
		makePtr(nonce),
		makePtr(key))

	if rc == 0 {
		return ciphertext, nil
	}

	return nil, fmt.Errorf("Error generating XOR-encrypted stream ciphertext (error code %v)", rc)
}
