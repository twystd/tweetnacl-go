package tweetnacl

import (
	"bytes"
	"testing"
)

// --- CryptoSignKeyPair ---

// Adapted from tests/core1.c)
func TestCryptoSignKeyPair(t *testing.T) {
	keypair, err := CryptoSignKeyPair()

	if err != nil {
		t.Errorf("crypto_sign_keypair: %v", err)
		return
	}

	if keypair.PublicKey == nil || len(keypair.PublicKey) != SIGN_PUBLICKEYBYTES {
		t.Errorf("crypto_sign_keypair: invalid public key")
		return
	}

	if keypair.SecretKey == nil || len(keypair.SecretKey) != SIGN_SECRETKEYBYTES {
		t.Errorf("crypto_sign_keypair: invalid secret key")
		return
	}
}

func BenchmarkCryptoSignKeyPair(b *testing.B) {
	for i := 0; i < b.N; i++ {
		CryptoSignKeyPair()
	}
}

// --- CryptoSign ---

// Adapted from http://ed25519.cr.yp.to/python/sign.py.
func TestCryptoSign(t *testing.T) {
	message := []byte{
		0x7c, 0xf3, 0x4f, 0x75,
		0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0,
		0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a,
		0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8,
		0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79,
		0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d,
		0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea,
		0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59,
		0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54,
		0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8,
		0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9,
		0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab,
		0xc8, 0x44, 0xf3, 0x1a}

	expected := []byte{
		0xbe, 0x71, 0xef, 0x48,
		0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9,
		0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd,
		0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92,
		0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d,
		0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b,
		0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b,
		0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66,
		0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75,
		0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0,
		0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a,
		0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8,
		0x8e, 0x3c, 0x56}

	signed, err := CryptoSign(message, key)

	if err != nil {
		t.Errorf("crypto_sign: %v", err)
		return
	}

	if !bytes.Equal(signed, expected) {
		t.Errorf("Invalid signed message [% x]", signed)
		return
	}
}

func BenchmarkCryptoSign(b *testing.B) {
	message := []byte{
		0x7c, 0xf3, 0x4f, 0x75,
		0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0,
		0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a,
		0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8,
		0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79,
		0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d,
		0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea,
		0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59,
		0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54,
		0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8,
		0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9,
		0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab,
		0xc8, 0x44, 0xf3, 0x1a}

	for i := 0; i < b.N; i++ {
		CryptoSign(message, key)
	}
}

// --- CryptoSignOpen ---

// Adapted from http://ed25519.cr.yp.to/python/sign.py.
func TestCryptoSignOpen(t *testing.T) {
	signed := []byte{
		0xbe, 0x71, 0xef, 0x48,
		0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9,
		0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd,
		0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92,
		0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d,
		0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b,
		0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b,
		0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66,
		0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75,
		0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0,
		0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a,
		0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8,
		0x8e, 0x3c, 0x56}

	key := []byte{
		0x3f, 0x60, 0xc7, 0x54,
		0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8,
		0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9,
		0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab,
		0xc8, 0x44, 0xf3, 0x1a}

	expected := []byte{
		0x7c, 0xf3, 0x4f, 0x75,
		0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0,
		0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a,
		0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8,
		0x8e, 0x3c, 0x56}

	message, err := CryptoSignOpen(signed, key)

	if err != nil {
		t.Errorf("%v", err)
		return
	}

	if !bytes.Equal(message, expected) {
		t.Errorf("Invalid unsigned message [% x]", signed)
		return
	}
}

func BenchmarkCryptoSignOpen(b *testing.B) {
	signed := []byte{
		0xbe, 0x71, 0xef, 0x48,
		0x06, 0xcb, 0x04, 0x1d,
		0x88, 0x5e, 0xff, 0xd9,
		0xe6, 0xb0, 0xfb, 0xb7,
		0x3d, 0x65, 0xd7, 0xcd,
		0xec, 0x47, 0xa8, 0x9c,
		0x8a, 0x99, 0x48, 0x92,
		0xf4, 0xe5, 0x5a, 0x56,
		0x8c, 0x4c, 0xc7, 0x8d,
		0x61, 0xf9, 0x01, 0xe8,
		0x0d, 0xbb, 0x62, 0x8b,
		0x86, 0xa2, 0x3c, 0xcd,
		0x59, 0x4e, 0x71, 0x2b,
		0x57, 0xfa, 0x94, 0xc2,
		0xd6, 0x7e, 0xc2, 0x66,
		0x34, 0x87, 0x85, 0x07,
		0x7c, 0xf3, 0x4f, 0x75,
		0xc3, 0xda, 0xc9, 0xa8,
		0x04, 0xd0, 0xfc, 0xd0,
		0x9e, 0xba, 0x9b, 0x29,
		0xc9, 0x48, 0x4e, 0x8a,
		0x01, 0x8f, 0xa9, 0xe0,
		0x73, 0x04, 0x2d, 0xf8,
		0x8e, 0x3c, 0x56}

	key := []byte{
		0x1a, 0xcd, 0xbb, 0x79,
		0x3b, 0x03, 0x84, 0x93,
		0x46, 0x27, 0x47, 0x0d,
		0x79, 0x5c, 0x3d, 0x1d,
		0xd4, 0xd7, 0x9c, 0xea,
		0x59, 0xef, 0x98, 0x3f,
		0x29, 0x5b, 0x9b, 0x59,
		0x17, 0x9c, 0xbb, 0x28,
		0x3f, 0x60, 0xc7, 0x54,
		0x1a, 0xfa, 0x76, 0xc0,
		0x19, 0xcf, 0x5a, 0xa8,
		0x2d, 0xcd, 0xb0, 0x88,
		0xed, 0x9e, 0x4e, 0xd9,
		0x78, 0x05, 0x14, 0xae,
		0xfb, 0x37, 0x9d, 0xab,
		0xc8, 0x44, 0xf3, 0x1a}

	for i := 0; i < b.N; i++ {
		CryptoSignOpen(signed, key)
	}
}
