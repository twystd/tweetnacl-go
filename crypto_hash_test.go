package tweetnacl

import (
	"bytes"
	"fmt"
	"testing"
)

// --- CryptoHash ---

// Adapted from tests/core1.c)
func TestCryptoHash(t *testing.T) {
	message := []byte("testing\n")

	expected := []byte{
		0x24, 0xf9, 0x50, 0xaa,
		0xc7, 0xb9, 0xea, 0x9b,
		0x3c, 0xb7, 0x28, 0x22,
		0x8a, 0x0c, 0x82, 0xb6,
		0x7c, 0x39, 0xe9, 0x6b,
		0x4b, 0x34, 0x47, 0x98,
		0x87, 0x0d, 0x5d, 0xae,
		0xe9, 0x3e, 0x3a, 0xe5,
		0x93, 0x1b, 0xaa, 0xe8,
		0xc7, 0xca, 0xcf, 0xea,
		0x4b, 0x62, 0x94, 0x52,
		0xc3, 0x80, 0x26, 0xa8,
		0x1d, 0x13, 0x8b, 0xc7,
		0xaa, 0xd1, 0xaf, 0x3e,
		0xf7, 0xbf, 0xd5, 0xec,
		0x64, 0x6d, 0x6c, 0x28}

	hash, err := CryptoHash(message)

	if err != nil {
		t.Errorf("crypto_hash: %v", err)
		return
	}

	if hash == nil {
		t.Errorf("crypto_hash: nil")
		return
	}

	if !bytes.Equal(hash, expected) {
		t.Errorf("crypto_hash: invalid SHA-512 hash (%v)", hash)
		return
	}
}

func BenchmarkCryptoHash(b *testing.B) {
	message := []byte("testing\n")

	for i := 0; i < b.N; i++ {
		CryptoHash(message)
	}
}

// --- CryptoHashBlocks ---

// There doesn't seem to be an official test so this one is worked up from
// the internal implementation of crypto_hash in tweetnacl.c.
func TestCryptoHashBlocks(t *testing.T) {
	iv := []byte{
		0x6a, 0x09, 0xe6, 0x67,
		0xf3, 0xbc, 0xc9, 0x08,
		0xbb, 0x67, 0xae, 0x85,
		0x84, 0xca, 0xa7, 0x3b,
		0x3c, 0x6e, 0xf3, 0x72,
		0xfe, 0x94, 0xf8, 0x2b,
		0xa5, 0x4f, 0xf5, 0x3a,
		0x5f, 0x1d, 0x36, 0xf1,
		0x51, 0x0e, 0x52, 0x7f,
		0xad, 0xe6, 0x82, 0xd1,
		0x9b, 0x05, 0x68, 0x8c,
		0x2b, 0x3e, 0x6c, 0x1f,
		0x1f, 0x83, 0xd9, 0xab,
		0xfb, 0x41, 0xbd, 0x6b,
		0x5b, 0xe0, 0xcd, 0x19,
		0x13, 0x7e, 0x21, 0x79}

	blocks := []byte{
		0x74, 0x65, 0x73, 0x74,
		0x69, 0x6e, 0x67, 0x0a,
		0x80, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40}

	expected := []byte{
		0x24, 0xf9, 0x50, 0xaa,
		0xc7, 0xb9, 0xea, 0x9b,
		0x3c, 0xb7, 0x28, 0x22,
		0x8a, 0x0c, 0x82, 0xb6,
		0x7c, 0x39, 0xe9, 0x6b,
		0x4b, 0x34, 0x47, 0x98,
		0x87, 0x0d, 0x5d, 0xae,
		0xe9, 0x3e, 0x3a, 0xe5,
		0x93, 0x1b, 0xaa, 0xe8,
		0xc7, 0xca, 0xcf, 0xea,
		0x4b, 0x62, 0x94, 0x52,
		0xc3, 0x80, 0x26, 0xa8,
		0x1d, 0x13, 0x8b, 0xc7,
		0xaa, 0xd1, 0xaf, 0x3e,
		0xf7, 0xbf, 0xd5, 0xec,
		0x64, 0x6d, 0x6c, 0x28}

	hash, err := CryptoHashBlocks(iv, blocks)

	if err != nil {
		t.Errorf("crypto_hashiblocks: %v", err)
		return
	}

	if hash == nil {
		t.Errorf("crypto_hashblocks: nil")
		return
	}

	if !bytes.Equal(hash, expected) {
		t.Errorf("crypto_hashblocks: invalid SHA-512 hash (%v)", hash)
		return
	}
}

func BenchmarkCryptoHashBlocks(b *testing.B) {
	hash := []byte{
		0x6a, 0x09, 0xe6, 0x67,
		0xf3, 0xbc, 0xc9, 0x08,
		0xbb, 0x67, 0xae, 0x85,
		0x84, 0xca, 0xa7, 0x3b,
		0x3c, 0x6e, 0xf3, 0x72,
		0xfe, 0x94, 0xf8, 0x2b,
		0xa5, 0x4f, 0xf5, 0x3a,
		0x5f, 0x1d, 0x36, 0xf1,
		0x51, 0x0e, 0x52, 0x7f,
		0xad, 0xe6, 0x82, 0xd1,
		0x9b, 0x05, 0x68, 0x8c,
		0x2b, 0x3e, 0x6c, 0x1f,
		0x1f, 0x83, 0xd9, 0xab,
		0xfb, 0x41, 0xbd, 0x6b,
		0x5b, 0xe0, 0xcd, 0x19,
		0x13, 0x7e, 0x21, 0x79}

	blocks := []byte{
		0x74, 0x65, 0x73, 0x74,
		0x69, 0x6e, 0x67, 0x0a,
		0x80, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40}

	for i := 0; i < b.N; i++ {
		hash, _ = CryptoHashBlocks(hash, blocks)
	}
}

// --- EXAMPLES ---

func ExampleCryptoHash() {
	message := []byte("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor")

	hash, err := CryptoHash(message)

	if err != nil {
		fmt.Printf("%v", err)
		return
	}

	fmt.Printf("[%x]", hash)

	// Output: [5dfaeb09829a546d8adcef4437957814b7b2f44a128600ab0e4f5322c6150cf5c33957f13055b9266e370c199bb764d4f38bb277b5f345e890d2e0bb3992c4dd]
}

func ExampleCryptoHashBlocks() {

	message := []string{
		"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut e",
		"nim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in",
		" reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, s",
		"unt in culpa qui officia deserunt mollit anim id est laborum                                                                    "}

	iv := []byte{
		0x6a, 0x09, 0xe6, 0x67,
		0xf3, 0xbc, 0xc9, 0x08,
		0xbb, 0x67, 0xae, 0x85,
		0x84, 0xca, 0xa7, 0x3b,
		0x3c, 0x6e, 0xf3, 0x72,
		0xfe, 0x94, 0xf8, 0x2b,
		0xa5, 0x4f, 0xf5, 0x3a,
		0x5f, 0x1d, 0x36, 0xf1,
		0x51, 0x0e, 0x52, 0x7f,
		0xad, 0xe6, 0x82, 0xd1,
		0x9b, 0x05, 0x68, 0x8c,
		0x2b, 0x3e, 0x6c, 0x1f,
		0x1f, 0x83, 0xd9, 0xab,
		0xfb, 0x41, 0xbd, 0x6b,
		0x5b, 0xe0, 0xcd, 0x19,
		0x13, 0x7e, 0x21, 0x79}

	hash := make([]byte, 64)

	copy(hash, []byte(iv))

	for _, block := range message {
		hash, _ = CryptoHashBlocks(hash, []byte(block))
	}

	fmt.Printf("[%x]", hash)

	// Output: [dc80679c10b1aaf584b90239c1f40bd82bdf8184086cd9106861ca4f4b024baf6a24d8ae74ad131f3fd0e5391ecafdd62c6ce2c3c0c66314f0d4554500613747]
}
